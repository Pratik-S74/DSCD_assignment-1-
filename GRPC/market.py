import grpc
from concurrent import futures
import shopping_pb2
import shopping_pb2_grpc

class MarketServicer(shopping_pb2_grpc.MarketServicer):
    def __init__(self):
        self.sellers_dict = {}
        self.items_dict = {}
        self.item_id_counter = 1
        self.buyers_wishlist = {}
        self.buyers_ratings = {}

    def RegisterSeller(self, request, context):
        seller_uuid = request.uuid
        seller_address = request.address

        if seller_address in self.sellers_dict.values():
            status = "FAILED"
        else:
            self.sellers_dict[seller_uuid] = seller_address
            status = "SUCCESS"

        print(f"Seller join request from {seller_address}, uuid = {seller_uuid}")
        return shopping_pb2.RegisterSellerResponse(status=status)

    def SellItem(self, request, context):
        seller_uuid = request.seller_uuid
        product_name = request.product_name
        category = request.category
        quantity = request.quantity
        description = request.description
        seller_address = request.seller_address
        price = request.price

        # Assume item_id is generated by the market
        item_id = str(self.item_id_counter)
        self.item_id_counter += 1

        self.items_dict[item_id] = {
            "product_name": product_name,
            "category": category,
            "quantity": quantity,
            "description": description,
            "seller_uuid": seller_uuid,
            "seller_address": seller_address,
            "price": price,
            "rating": 0.0  # Initialize rating to 0.0
        }

        print(f"Sell Item request from {seller_address}")
        return shopping_pb2.SellItemResponse(status="SUCCESS", item_id=item_id)

    def UpdateItem(self, request, context):
        seller_uuid = request.seller_uuid
        item_id = request.item_id
        new_price = request.new_price
        new_quantity = request.new_quantity
        seller_address = request.seller_address

        if item_id in self.items_dict:
            item = self.items_dict[item_id]

            # Verify credentials
            if item["seller_uuid"] == seller_uuid and item["seller_address"] == seller_address:
                item["price"] = new_price
                item["quantity"] = new_quantity

                # Notify buyers who wish-listed this item
                self.notify_wishlist(item_id)

                status = "SUCCESS"
            else:
                status = "FAILED"
        else:
            status = "FAILED"

        print(f"Update Item {item_id} request from {seller_address}")
        return shopping_pb2.Response(status=status)

    def DeleteItem(self, request, context):
        seller_uuid = request.seller_uuid
        item_id = request.item_id
        seller_address = request.seller_address

        if item_id in self.items_dict:
            item = self.items_dict[item_id]

            # Verify credentials
            if item["seller_uuid"] == seller_uuid and item["seller_address"] == seller_address:
                del self.items_dict[item_id]
                status = "SUCCESS"
            else:
                status = "FAILED"
        else:
            status = "FAILED"

        print(f"Delete Item {item_id} request from {seller_address}")
        return shopping_pb2.Response(status=status)

    def DisplaySellerItems(self, request, context):
        seller_uuid = request.seller_uuid
        seller_address = request.seller_address

        items_list = []
        for item_id, item in self.items_dict.items():
            if item["seller_uuid"] == seller_uuid and item["seller_address"] == seller_address:
                items_list.append(shopping_pb2.DisplaySellerItemsResponse.Item(
                    item_id=item_id,
                    price=item["price"],
                    product_name=item["product_name"],
                    category=item["category"],
                    description=item["description"],
                    quantity=item["quantity"],
                    seller_address=item["seller_address"],
                    rating=item["rating"]
                ))

        print(f"Display Items request from {seller_address}")
        return shopping_pb2.DisplaySellerItemsResponse(items=items_list)

    def SearchItem(self, request, context):
        item_name = request.item_name
        category = request.category

        items_list = []
        for item_id, item in self.items_dict.items():
            if (not item_name or item_name.lower() in item["product_name"].lower()) and \
               (category == "ANY" or item["category"] == category):
                items_list.append(shopping_pb2.SearchItemResponse.Item(
                    item_id=item_id,
                    price=item["price"],
                    product_name=item["product_name"],
                    category=item["category"],
                    description=item["description"],
                    quantity=item["quantity"],
                    rating=item["rating"],
                    seller_address=item["seller_address"]
                ))

        print(f"Search request for Item name: {item_name}, Category: {category}")
        return shopping_pb2.SearchItemResponse(items=items_list)

    def BuyItem(self, request, context):
        item_id = request.item_id
        quantity = request.quantity
        buyer_address = request.buyer_address

        if item_id in self.items_dict:
            item = self.items_dict[item_id]

            if item["quantity"] >= quantity:
                item["quantity"] -= quantity

                # Notify the seller about the purchase
                self.notify_seller(item_id, quantity, buyer_address)

                status = "SUCCESS"
            else:
                status = "FAILED - Not enough stock"
        else:
            status = "FAILED - Invalid item ID"

        print(f"Buy request {quantity} of item {item_id}, from {buyer_address}")
        return shopping_pb2.BuyItemResponse(status=status)

    def AddToWishList(self, request, context):
        item_id = request.item_id
        buyer_address = request.buyer_address

        if item_id in self.items_dict:
            if item_id not in self.buyers_wishlist:
                self.buyers_wishlist[item_id] = []

            if buyer_address not in self.buyers_wishlist[item_id]:
                self.buyers_wishlist[item_id].append(buyer_address)
                status = "SUCCESS"
            else:
                status = "FAILED - Already in wish list"
        else:
            status = "FAILED - Invalid item ID"

        print(f"Wishlist request of item {item_id}, from {buyer_address}")
        return shopping_pb2.Response(status=status)

    def RateItem(self, request, context):
        item_id = request.item_id
        buyer_address = request.buyer_address
        rating = request.rating

        if item_id in self.items_dict:
            if buyer_address not in self.buyers_ratings:
                self.buyers_ratings[buyer_address] = set()

            if item_id not in self.buyers_ratings[buyer_address]:
                self.items_dict[item_id]["rating"] = (self.items_dict[item_id]["rating"] + rating) / 2
                self.buyers_ratings[buyer_address].add(item_id)
                status = "SUCCESS"
            else:
                status = "FAILED - Already rated this item"
        else:
            status = "FAILED - Invalid item ID"

        print(f"{buyer_address} rated item {item_id} with {rating} stars.")
        return shopping_pb2.Response(status=status)

    def notify_seller(self, item_id, quantity, buyer_address):
        seller_address = self.items_dict[item_id]["seller_address"]
        self.notify_client(item_id, seller_address)

    def notify_wishlist(self, item_id):
        if item_id in self.buyers_wishlist:
            for buyer_address in self.buyers_wishlist[item_id]:
                self.notify_client(item_id, buyer_address)

    def notify_client(self, item_id, client_address):
        channel = grpc.insecure_channel(client_address)
        client_stub = shopping_pb2_grpc.NotifyClientStub(channel)

        notification = f"The Following Item has been updated:\n\nItem ID: {item_id}, " \
                       f"Price: ${self.items_dict[item_id]['price']}, " \
                       f"Name: {self.items_dict[item_id]['product_name']}, " \
                       f"Category: {self.items_dict[item_id]['category']}, " \
                       f"Description: {self.items_dict[item_id]['description']}, " \
                       f"Quantity Remaining: {self.items_dict[item_id]['quantity']}, " \
                       f"Rating: {self.items_dict[item_id]['rating']} / 5  |  " \
                       f"Seller: {self.items_dict[item_id]['seller_address']}"

        client_stub.Notify(shopping_pb2.Notification(message=notification))

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    shopping_pb2_grpc.add_MarketServicer_to_server(MarketServicer(), server)
    server.add_insecure_port('[::]:50051')
    print("Market server started. Listening on port 50051.")
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
